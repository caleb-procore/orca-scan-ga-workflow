#################################################
#
# Summary
# On a PR, simulate a merge (no commit), build and scan the Docker image only
# On a merge, build, scan and deploy the Docker image to ECR.
# 
# Pre-requisites: 
#
# 1. IAM OIDC Role for Github Actions in the target AWS account.
#
# 2. SSM Parameters for the following:
#     ECR Repo Name
#     ECR Image Tag
#     ECS Cluster Name
#     ECS Service Name
#     ECS Task Definition Name
#     ECS Container Name
#
#################################################

name: Continuous Deployment Workflow | Set Environment

on:
  workflow_dispatch:
  pull_request:
    types: [ opened, synchronize, reopened ]
  push:
    branches:
      - main
      - staging
      - develop

permissions:
  id-token: write # need this for OIDC
  contents: read # need this for actions/checkout
  packages: write

env:
  AWS_ACCOUNT_ID_DEV: 785368447960
  AWS_ACCOUNT_ID_STG: 785368447960
  AWS_ACCOUNT_ID_PROD: 723214535755
  OIDC_ROLE_ARN_DEV: arn:aws:iam::785368447960:role/github-actions-oidc-role
  OIDC_ROLE_ARN_STG: arn:aws:iam::785368447960:role/github-actions-oidc-role
  OIDC_ROLE_ARN_PROD: arn:aws:iam::723214535755:role/github-actions-oidc-role
  #  OIDC_ROLE_ARN_DEV: arn:aws:iam::${{ env.AWS_ACCOUNT_ID_DEV }}:role/github-actions-oidc-role
  #  OIDC_ROLE_ARN_STG: arn:aws:iam::${{ env.AWS_ACCOUNT_ID_STG }}:role/github-actions-oidc-role
  #  OIDC_ROLE_ARN_PROD: arn:aws:iam::${{ env.AWS_ACCOUNT_ID_PROD }}:role/github-actions-oidc-role
  APP_NAME_DEV: procore-io-platform
  APP_NAME_STG: procore-io-platform-stg
  APP_NAME_PROD: procore-io-platform
  SERVICE_NAME_DEV: polaris-backend
  SERVICE_NAME_STG: polaris-backend-stg
  SERVICE_NAME_PROD: polaris-backend
  APP_DIRECTORY: src
  DOCKERFILE_PATH: src/gademo/Dockerfile
  ORCA_API_TOKEN: ${{ secrets.ORCA_API_TOKEN }}

jobs:
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      ENV: ${{ steps.set_environment.outputs.ENV }}
      OIDC_ROLE_ARN: ${{ steps.set_environment.outputs.OIDC_ROLE_ARN }}
      APP_NAME: ${{ steps.set_environment.outputs.APP_NAME }}
      SERVICE_NAME: ${{ steps.set_environment.outputs.SERVICE_NAME }}
      ACTION_TYPE: ${{ steps.set_environment.outputs.ACTION_TYPE }}
      AWS_ACCOUNT_ID: ${{ steps.set_environment.outputs.AWS_ACCOUNT_ID }}
      APP_DIRECTORY: ${{ env.APP_DIRECTORY }}
      DOCKERFILE_PATH: ${{ env.DOCKERFILE_PATH }}
    steps:
      - name: Set deployment environment based on Git branch
        id: set_environment
        run: |
          if [[ "$GITHUB_REF" == "refs/heads/main" ]]; then
            ENV="prod"
            OIDC_ROLE_ARN=${{ env.OIDC_ROLE_ARN_PROD }}
            APP_NAME=${{ env.APP_NAME_PROD }}
            SERVICE_NAME=${{ env.SERVICE_NAME_PROD }}
            AWS_ACCOUNT_ID=${{ env.AWS_ACCOUNT_ID_PROD }}
          elif [[ "$GITHUB_REF" == "refs/heads/staging" ]]; then
            ENV="stg"
            OIDC_ROLE_ARN=${{ env.OIDC_ROLE_ARN_STG }}
            APP_NAME=${{ env.APP_NAME_STG }}
            # APP_NAME=${{ steps.needs.APP_NAME_STG }}
            SERVICE_NAME=${{ env.SERVICE_NAME_STG }}
            AWS_ACCOUNT_ID=${{ env.AWS_ACCOUNT_ID_STG }}
          elif [[ "$GITHUB_REF" == "refs/heads/develop" ]]; then
            ENV="dev"
            OIDC_ROLE_ARN=${{ env.OIDC_ROLE_ARN_DEV }}
            APP_NAME=${{ env.APP_NAME_DEV }}
            SERVICE_NAME=${{ env.SERVICE_NAME_DEV }}
            AWS_ACCOUNT_ID=${{ env.AWS_ACCOUNT_ID_DEV }}
          else
            ENV="dev"
            OIDC_ROLE_ARN=${{ env.OIDC_ROLE_ARN_DEV }}
            APP_NAME=${{ env.APP_NAME_DEV }}
            SERVICE_NAME=${{ env.SERVICE_NAME_DEV }}
            AWS_ACCOUNT_ID=${{ env.AWS_ACCOUNT_ID_DEV }}
          fi

          if [[ "$GITHUB_EVENT_NAME" == "pull_request" ]]; then
            ACTION_TYPE="build_scan_only"
          elif [[ "$GITHUB_EVENT_NAME" == "push" ]]; then
            ACTION_TYPE="build_scan_deploy"
          fi

          echo "APP_NAME=$APP_NAME" >> "$APP_NAME"
          echo "ENV=$ENV" >> "$GITHUB_OUTPUT"
          echo "OIDC_ROLE_ARN=$OIDC_ROLE_ARN" >> "$GITHUB_OUTPUT"
          echo "APP_NAME=APP_NAME" >> "$GITHUB_OUTPUT"
          echo "SERVICE_NAME=$SERVICE_NAME" >> "$GITHUB_OUTPUT"
          echo "ACTION_TYPE=$ACTION_TYPE" >> "$GITHUB_OUTPUT"
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> "$GITHUB_OUTPUT"
  
  getparams:
    needs: [ setup ]
    runs-on: ubuntu-latest
    name: Get SSM Parameters
    outputs:
      ECR_REPO_NAME: ${{ steps.ssm.outputs.ECR_REPO_NAME }}
      ECS_CLUSTER_NAME: ${{ steps.ssm.outputs.ECS_CLUSTER_NAME }}
      ECS_SERVICE_NAME: ${{ steps.ssm.outputs.ECS_SERVICE_NAME }}
      ECS_TASK_DEFINITION_NAME: "${{ steps.ssm.outputs.ECS_TASK_DEFINITION_NAME }}"
      ECS_CONTAINER_NAME: ${{ steps.ssm.outputs.ECS_CONTAINER_NAME }}
      ECR_IMAGE_TAG_PARAM: "${{ steps.ssm.outputs.ECR_IMAGE_TAG_PARAM }}"
    steps:
      - name: Set SSM Parameter Names
        id: ssm
        env:
          APP_NAME: ${{ needs.setup.outputs.APP_NAME }}
          ENV: ${{ needs.setup.outputs.ENV }}
          SERVICE_NAME: ${{ needs.setup.outputs.SERVICE_NAME }}
        run: |
          aws --version
          echo APP_NAME=$APP_NAME
          echo ENV=$ENV
          echo SERVICE_NAME=$SERVICE_NAME

          ##### Dynamically set the SSM Parameter Names #####
          ECR_REPO_NAME_PARAM="/${APP_NAME}/${ENV}/${SERVICE_NAME}/ecr-repo-name"
          ECR_IMAGE_TAG_PARAM="/${APP_NAME}/${ENV}/${SERVICE_NAME}/ecr-image-tag"
          ECS_CLUSTER_NAME_PARAM="/${APP_NAME}/${ENV}/${SERVICE_NAME}/ecs-cluster-name"
          ECS_SERVICE_NAME_PARAM="/${APP_NAME}/${ENV}/${SERVICE_NAME}/ecs-service-name"
          ECS_TASK_DEFINITION_NAME_PARAM="/${APP_NAME}/${ENV}/${SERVICE_NAME}/ecs-task-definition-name"
          ECS_CONTAINER_NAME_PARAM="/${APP_NAME}/${ENV}/${SERVICE_NAME}/ecs-container-name"

          ##### Print Param Names - Validate String Interpolation worked #####
          echo "ECR_REPO_NAME_PARAM=$ECR_REPO_NAME_PARAM"
          echo "ECR_IMAGE_TAG_PARAM=$ECR_IMAGE_TAG_PARAM"
          echo "ECS_CLUSTER_NAME_PARAM=$ECS_CLUSTER_NAME_PARAM"
          echo "ECS_SERVICE_NAME_PARAM=$ECS_SERVICE_NAME_PARAM"
          echo "ECS_TASK_DEFINITION_NAME_PARAM=$ECS_TASK_DEFINITION_NAME_PARAM"
          echo "ECS_CONTAINER_NAME_PARAM=$ECS_CONTAINER_NAME_PARAM"

          ##### Save SSM Parameter Name as Github Outputs #####
          ##### ecs.yaml script read/writes image tag to this SSM Parameter.
          echo "ECR_IMAGE_TAG_PARAM=$ECR_IMAGE_TAG_PARAM" >> "$GITHUB_OUTPUT"

          ##### Get SSM Parameters #####
          ECR_REPO_NAME=$(aws ssm get-parameter --name ${ECR_REPO_NAME_PARAM} --output json | jq -r ".Parameter.Value")
          ECS_CLUSTER_NAME=$(aws ssm get-parameter --name ${ECS_CLUSTER_NAME_PARAM} --output json | jq -r ".Parameter.Value")
          ECS_SERVICE_NAME=$(aws ssm get-parameter --name ${ECS_SERVICE_NAME_PARAM} --output json | jq -r ".Parameter.Value")
          ECS_TASK_DEFINITION_NAME=$(aws ssm get-parameter --name ${ECS_TASK_DEFINITION_NAME_PARAM} --output json | jq -r ".Parameter.Value")
          ECS_CONTAINER_NAME=$(aws ssm get-parameter --name ${ECS_CONTAINER_NAME_PARAM} --output json | jq -r ".Parameter.Value")

          ##### Print SSM Parameters #####
          echo "ECR_REPO_NAME=$ECR_REPO_NAME"
          echo "ECS_CLUSTER_NAME=$ECS_CLUSTER_NAME"
          echo "ECS_SERVICE_NAME=$ECS_SERVICE_NAME"
          echo "ECS_TASK_DEFINITION_NAME=$ECS_TASK_DEFINITION_NAME"
          echo "ECS_CONTAINER_NAME=$ECS_CONTAINER_NAME"
          
          ##### Save SSM Parameter Values as Github Outputs #####
          echo "ECR_REPO_NAME=$ECR_REPO_NAME" >> "$GITHUB_OUTPUT"
          echo "ECS_CLUSTER_NAME=$ECS_CLUSTER_NAME" >> "$GITHUB_OUTPUT"
          echo "ECS_SERVICE_NAME=$ECS_SERVICE_NAME" >> "$GITHUB_OUTPUT"
          echo "ECS_TASK_DEFINITION_NAME=$ECS_TASK_DEFINITION_NAME" >> "$GITHUB_OUTPUT"
          echo "ECS_CONTAINER_NAME=$ECS_CONTAINER_NAME" >> "$GITHUB_OUTPUT"

  build-scan:
    needs: [ getparams ]
    name: Build and Scan Docker Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout target branch of the pull request (dev, staging, main)
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          fetch-depth: 0

      - name: Fetch all branches
        run: git fetch --all

      - name: Debug Git Status
        run: |
          git status

      - name: Checkout the latest commit from the head of pull request
        if: github.event_name == 'pull_request'
        run: git checkout ${{ github.event.pull_request.head.ref }}

      - name: Debug Git Status
        run: |
          git status

      - name: Build Docker Image on simulated merge
        if: github.event_name == 'pull_request'
        run: |
          echo "DOCKERFILE_PATH | ${{ env.DOCKERFILE_PATH }}"
          echo "APP_NAME | ${{ needs.setup.outputs.APP_NAME }}"
          echo "APP_NAME | ${{ env.APP_NAME }}"
          echo "APP_DIRECTORY | ${{ env.APP_DIRECTORY }}"
          echo "APP_DIRECTORY | ${{ needs.setup.outputs.APP_DIRECTORY }}"
          git merge --no-ff ${{ github.event.pull_request.head.sha }}
          docker build -t ${{ needs.setup.outputs.APP_NAME }}:${{ github.sha }} -f ${{ env.DOCKERFILE_PATH }} ${{ needs.setup.outputs.APP_DIRECTORY }}

      - name: Build Docker Image on merge to env branch (main, staging, develop)
        if: github.event_name == 'push'
        run: |
          docker build -t ${{ needs.setup.outputs.APP_NAME }}:${{ github.sha }} -f ${{ needs.setup.outputs.DOCKERFILE_PATH }} ${{ needs.setup.outputs.APP_DIRECTORY }}

      - name: Install Orca CLI
        run: |
          curl -L https://download.orcasecurity.io/orca-cli-linux -o /usr/local/bin/orca
          chmod +x /usr/local/bin/orca

      - name: Orca Image Scan
        run: |
          orca scan --image $ECR_REPO_NAME:$IMAGE_TAG --key ${{ secrets.ORCA_API_TOKEN }}
  
  #      - name: Orca Image Scan (Simulated Merge & Merge)
  #        # if: github.event_name == 'push'
  #        # if: github.event_name == 'pull_request'
  #        uses: orca-security/orca-image-scan-action@v1
  #        with:
  #          image: ${{ needs.setup.outputs.APP_NAME }}:${{ github.sha }}
  #        env:
  #          ORCA_API_TOKEN: ${{ secrets.ORCA_API_TOKEN }}

  deploy-ecs-api-container:
    # if: github.event_name == 'push' && github.ref =~ 'refs/heads/(main|develop|staging)'
    if: false
    #    if: github.event_name == 'push' && (
    #      github.ref == 'refs/heads/main' ||
    #      github.ref == 'refs/heads/develop' ||
    #      github.ref == 'refs/heads/staging'
    #      )
    needs: [ build-scan ]
    name: Deploy ECS Container
    uses: ./.github/workflows/ecs.yml
    with:
      oidc-role-arn: ${{ needs.setup.outputs.OIDC_ROLE_ARN }}
      ecr-repo-name: ${{ needs.getparams.outputs.ECR_REPO_NAME }}
      ecs-cluster-name: ${{ needs.getparams.outputs.ECS_CLUSTER_NAME }}
      ecs-service-name: ${{ needs.getparams.outputs.ECS_SERVICE_NAME }}
      ecs-task-definition-name: ${{ needs.getparams.outputs.ECS_TASK_DEFINITION_NAME }}
      ecs-container-name: ${{ needs.getparams.outputs.ECS_CONTAINER_NAME }}
      app-directory: ${{ needs.setup.outputs.APP_DIRECTORY }}
      dockerfile-path: ${{ needs.setup.outputs.DOCKERFILE_PATH }}